<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Offline - School SIS</title>
    <link rel="stylesheet" href="styles/offline.css">
</head>
<body>
    <div class="offline-container">
        <div class="offline-icon">ðŸ“±</div>
        <h1>You're Offline</h1>
        <p>
            It looks like you're not connected to the internet. 
            Don't worry - School SIS works offline too!
        </p>
        
        <div class="features">
            <h3>Available Offline Features:</h3>
            <ul>
                <li>View cached student information</li>
                <li>Access previously loaded grades</li>
                <li>Review attendance records</li>
                <li>Use basic navigation</li>
            </ul>
        </div>
        
        <div class="connection-status" id="connection-status">
            <span class="status-indicator status-checking" id="status-indicator"></span>
            <span id="connection-text">Checking connection...</span>
        </div>
        
        <div class="progress-indicator" id="progress-indicator" style="display: none;">
            <div>Testing connectivity...</div>
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
        </div>
        
        <button class="retry-button" id="retry-button" onclick="checkConnection()">
            Check Connection
        </button>
    </div>

    <script>
        // Enhanced connection checking with better UX
        class ConnectionChecker {
            constructor() {
                this.statusText = document.getElementById('connection-text');
                this.statusIndicator = document.getElementById('status-indicator');
                this.connectionStatus = document.getElementById('connection-status');
                this.progressIndicator = document.getElementById('progress-indicator');
                this.progressFill = document.getElementById('progress-fill');
                this.retryButton = document.getElementById('retry-button');
                this.isChecking = false;
                this.retryCount = 0;
                this.maxRetries = 3;
                
                this.init();
            }
            
            init() {
                // Listen for online/offline events
                window.addEventListener('online', () => this.handleOnline());
                window.addEventListener('offline', () => this.handleOffline());
                
                // Initial check
                this.checkConnection();
                
                // Auto-retry every 30 seconds
                setInterval(() => {
                    if (!this.isChecking && !navigator.onLine) {
                        this.checkConnection();
                    }
                }, 30000);
            }
            
            async checkConnection() {
                if (this.isChecking) return;
                
                this.isChecking = true;
                this.retryButton.disabled = true;
                this.retryButton.classList.add('loading');
                this.progressIndicator.style.display = 'block';
                
                // Update status
                this.updateStatus('checking', 'Testing connection...');
                
                try {
                    // Test multiple endpoints for better reliability
                    const endpoints = [
                        '/api/health',
                        'https://www.google.com/favicon.ico',
                        'https://httpbin.org/status/200'
                    ];
                    
                    let connected = false;
                    let progress = 0;
                    
                    for (const endpoint of endpoints) {
                        if (connected) break;
                        
                        try {
                            const response = await this.testEndpoint(endpoint);
                            if (response.ok) {
                                connected = true;
                            }
                        } catch (error) {
                            console.log(`Endpoint ${endpoint} failed:`, error);
                        }
                        
                        progress += 33;
                        this.updateProgress(progress);
                        
                        // Small delay between tests
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                    
                    if (connected) {
                        this.handleConnectionRestored();
                    } else {
                        this.handleConnectionFailed();
                    }
                    
                } catch (error) {
                    console.error('Connection check failed:', error);
                    this.handleConnectionFailed();
                } finally {
                    this.isChecking = false;
                    this.retryButton.disabled = false;
                    this.retryButton.classList.remove('loading');
                    this.progressIndicator.style.display = 'none';
                }
            }
            
            async testEndpoint(url) {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);
                
                try {
                    const response = await fetch(url, {
                        method: 'HEAD',
                        cache: 'no-cache',
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);
                    return response;
                } catch (error) {
                    clearTimeout(timeoutId);
                    throw error;
                }
            }
            
            updateStatus(status, text) {
                this.statusText.textContent = text;
                this.statusIndicator.className = `status-indicator status-${status}`;
                this.connectionStatus.className = `connection-status ${status}`;
            }
            
            updateProgress(percentage) {
                this.progressFill.style.width = `${percentage}%`;
            }
            
            handleConnectionRestored() {
                this.retryCount = 0;
                this.updateStatus('online', 'Connection restored! Redirecting...');
                
                // Show success message briefly before redirecting
                setTimeout(() => {
                    window.location.href = '/';
                }, 2000);
            }
            
            handleConnectionFailed() {
                this.retryCount++;
                const message = this.retryCount >= this.maxRetries 
                    ? 'Still offline. Please check your internet connection.'
                    : `Connection failed. Retry ${this.retryCount}/${this.maxRetries}`;
                
                this.updateStatus('offline', message);
                
                // Reset retry count after max retries
                if (this.retryCount >= this.maxRetries) {
                    setTimeout(() => {
                        this.retryCount = 0;
                    }, 60000); // Reset after 1 minute
                }
            }
            
            handleOnline() {
                this.updateStatus('online', 'Connection detected! Verifying...');
                setTimeout(() => this.checkConnection(), 1000);
            }
            
            handleOffline() {
                this.updateStatus('offline', 'Connection lost. Retrying...');
                this.retryCount = 0;
            }
        }
        
        // Initialize connection checker
        const connectionChecker = new ConnectionChecker();
        
        // Global function for button click
        function checkConnection() {
            connectionChecker.checkConnection();
        }
    </script>
</body>
</html>